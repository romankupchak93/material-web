{"version":3,"file":"field_test.js","sourceRoot":"","sources":["field_test.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// import 'jasmine'; (google3-only)\n\nimport {html} from 'lit';\nimport {customElement} from 'lit/decorators.js';\n\nimport {Environment} from '../../testing/environment.js';\nimport {FieldHarness} from '../harness.js';\n\nimport {Field} from './field.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'md-test-field': TestField;\n  }\n}\n\n@customElement('md-test-field')\nclass TestField extends Field {\n  get labelText() {\n    return this.renderRoot.querySelector('.label')?.textContent ?? '';\n  }\n\n  // Ensure floating/resting labels are both rendered\n  protected override renderMiddleContents() {\n    return html`\n      ${this.renderFloatingLabel()}\n      ${this.renderRestingLabel()}\n      ${super.renderMiddleContents()}\n    `;\n  }\n}\n\ndescribe('Field', () => {\n  const env = new Environment();\n\n  async function setupTest(props: Partial<Field> = {}) {\n    // Variant type does not matter for shared tests\n    const template = html`\n      <md-test-field\n        .label=${props.label}\n        ?disabled=${props.disabled ?? false}\n        .error=${props.error ?? false}\n        .populated=${props.populated ?? false}\n        .required=${props.required ?? false}\n      >\n        <input>\n      </md-test-field>\n    `;\n    const root = env.render(template);\n    const instance = root.querySelector('md-test-field');\n    if (!instance) {\n      throw new Error('Could not query rendered <md-test-field>.');\n    }\n\n    await env.waitForStability();\n    return {\n      instance,\n      harness: new FieldHarness(instance),\n    };\n  }\n\n  it('should unfocus field when disabled', async () => {\n    // Setup.\n    const {instance, harness} = await setupTest();\n    await harness.focusWithKeyboard();\n    await env.waitForStability();\n    // Test case.\n    instance.disabled = true;\n    await env.waitForStability();\n    // Assertion.\n    expect(instance.focused)\n        .withContext('focused is false after disabled is set to true')\n        .toBe(false);\n  });\n\n  it('should not allow focus when disabled', async () => {\n    // Setup.\n    const {instance, harness} = await setupTest({disabled: true});\n    await harness.focusWithKeyboard();\n    // Test case.\n    await env.waitForStability();\n    // Assertion.\n    expect(instance.focused)\n        .withContext('focused set back to false when disabled')\n        .toBe(false);\n  });\n\n  /*\n    TODO(b/225951156): update animation tests since l2w refactor breaks them\n    describe('#animateLabelIfNeeded()', () => {\n      it('should update visible label type to resting before animation\n    finishes', async () => {\n           // Setup.\n           const {instance, harness} = await setupTest({label: 'Label'});\n           const floatingLabel = await instance.floatingLabelElement;\n           // Test case.\n           await harness.focusWithKeyboard();\n           await env.waitForStability();\n           // Assertion.\n           expect(floatingLabel.classList)\n               .withContext('should display resting label for animation')\n               .not.toContain('label--hidden');\n         });\n\n      it('should update visible label type to resting immediately when resting',\n         async () => {\n           // Setup.\n           const {instance, harness} = await setupTest({label: 'Label'});\n           const restingLabel = await instance.restingLabelElement;\n           await harness.focusWithKeyboard();\n           // Test case.\n           await harness.blur();\n           // Assertion.\n           expect(restingLabel.classList)\n               .withContext('should display resting label for animation')\n               .not.toContain('label--hidden');\n         });\n\n      it('should update visible label type after floating animation ends',\n         async () => {\n           // Setup.\n           const {instance, harness} = await setupTest({label: 'Label'});\n           const animation = new Animation();\n           const floatingLabel = await instance.floatingLabelElement;\n           const restingLabel = await instance.restingLabelElement;\n           spyOn(restingLabel, 'animate').and.returnValue(animation);\n           // Test case.\n           await harness.focusWithKeyboard();\n           await env.waitForStability();\n           animation.play();\n           await env.waitForStability();\n           // Assertion.\n           expect(floatingLabel.classList)\n               .withContext('visible label should be floating after focusing')\n               .not.toContain('label--hidden');\n         });\n\n      it('should update visible label type after resting animation ends',\n         async () => {\n           // Setup.\n           const {instance, harness} = await setupTest({label: 'Label'});\n           await harness.focusWithKeyboard();\n           const animation = new Animation();\n           const restingLabel = await instance.restingLabelElement;\n           spyOn(restingLabel, 'animate').and.returnValue(animation);\n           // Test case.\n           await harness.blur();\n           await env.waitForStability();\n           animation.play();\n           await env.waitForStability();\n           // Assertion.\n           expect(restingLabel.classList)\n               .withContext('visible label should be resting after unfocusing')\n               .not.toContain('label--hidden');\n         });\n\n      it('should animate label when focused changes', async () => {\n        // Setup.\n        const {instance, harness} = await setupTest({label: 'Label'});\n        const floatingLabel = await instance.floatingLabelElement;\n        spyOn(floatingLabel, 'animate').and.callThrough();\n        // Test case.\n        await harness.focusWithKeyboard();\n        await env.waitForStability();\n        // Assertion.\n        expect(floatingLabel.animate).toHaveBeenCalledTimes(1);\n      });\n\n      it('should animate label when populated changes', async () => {\n        // Setup.\n        const {instance} = await setupTest({label: 'Label'});\n        const floatingLabel = await instance.floatingLabelElement;\n        spyOn(floatingLabel, 'animate').and.callThrough();\n        // Test case.\n        instance.populated = true;\n        await env.waitForStability();\n        // Assertion.\n        expect(floatingLabel.animate).toHaveBeenCalledTimes(1);\n      });\n\n      it('should not animate when there is no label', async () => {\n        // Setup.\n        const {instance, harness} = await setupTest({label: undefined});\n        const floatingLabel = await instance.floatingLabelElement;\n        spyOn(floatingLabel, 'animate').and.callThrough();\n        // Test case.\n        await harness.focusWithKeyboard();\n        await env.waitForStability();\n        // Assertion.\n        expect(floatingLabel.animate)\n            .withContext('should not animate label when there is none')\n            .not.toHaveBeenCalled();\n      });\n\n      it('should still set the visible label type when there is no label',\n         async () => {\n           // Setup.\n           const {instance, harness} = await setupTest({label: undefined});\n           const floatingLabel = await instance.floatingLabelElement;\n           await harness.focusWithKeyboard();\n           // Test case.\n           await env.waitForStability();\n           // Assertion.\n           expect(floatingLabel.classList)\n               .withContext(\n                   'focusing should still set visible label type to floating')\n               .toContain('label--hidden');\n\n           // Test case.\n           await harness.blur();\n           await env.waitForStability();\n           // Test case.\n           expect(floatingLabel.classList)\n               .withContext(\n                   'unfocusing should still set visible label type to resting')\n               .not.toContain('label--hidden');\n         });\n\n      it('should not animate if focusing a populated field', async () => {\n        // Setup.\n        const {instance, harness} =\n            await setupTest({label: 'Label', populated: true});\n        const floatingLabel = await instance.floatingLabelElement;\n        spyOn(floatingLabel, 'animate').and.callThrough();\n        // Test case.\n        await harness.focusWithKeyboard();\n        await env.waitForStability();\n        // Assertion.\n        expect(floatingLabel.animate)\n            .withContext('should not animate when focusing a populated field')\n            .not.toHaveBeenCalled();\n      });\n\n      it('should not animate if populating a focused field', async () => {\n        // Setup.\n        const {instance, harness} = await setupTest({label: 'Label'});\n        await harness.focusWithKeyboard();\n        const floatingLabel = await instance.floatingLabelElement;\n        spyOn(floatingLabel, 'animate').and.callThrough();\n        // Test case.\n        instance.populated = true;\n        await env.waitForStability();\n        // Assertion.\n        expect(floatingLabel.animate)\n            .withContext('should not animate when populated a focused field')\n            .not.toHaveBeenCalled();\n      });\n\n      it('should cancel previous animation', async () => {\n        // Set up.\n        const {instance, harness} = await setupTest({label: 'Label'});\n        const restingLabel = await instance.restingLabelElement;\n        const firstAnimation = new Animation();\n        spyOn(firstAnimation, 'cancel').and.callThrough();\n        const secondAnimation = new Animation();\n        spyOn(secondAnimation, 'cancel').and.callThrough();\n        spyOn(restingLabel, 'animate')\n            .and.returnValues(firstAnimation, secondAnimation);\n        // Test case.\n        await harness.focusWithKeyboard();\n        await env.waitForStability();\n        await harness.blur();\n        await env.waitForStability();\n        // Assertion.\n        expect(firstAnimation.cancel)\n            .withContext('first animation should be cancelled')\n            .toHaveBeenCalled();\n        expect(secondAnimation.cancel)\n            .withContext('second animation should play')\n            .not.toHaveBeenCalled();\n      });\n    });\n  */\n  describe('.label', () => {\n    it('should render empty string when there is no label', async () => {\n      // Setup.\n      // Test case.\n      const {instance} = await setupTest({label: undefined});\n      // Assertion.\n      expect(instance.labelText)\n          .withContext(\n              'label text should be empty string if label is not provided')\n          .toBe('');\n    });\n\n    it('should render label', async () => {\n      // Setup.\n      // Test case.\n      const labelValue = 'Label';\n      const {instance} = await setupTest({label: labelValue});\n      // Assertion.\n      expect(instance.labelText)\n          .withContext('label text should equal label when not required')\n          .toBe(labelValue);\n    });\n\n    it('should adds asterisk if required', async () => {\n      // Setup.\n      // Test case.\n      const labelValue = 'Label';\n      const {instance} = await setupTest({required: true, label: labelValue});\n      // Assertion.\n      expect(instance.labelText)\n          .withContext(\n              'label text should equal label with asterisk when required')\n          .toBe(`${labelValue}*`);\n    });\n\n    it('should not render asterisk if required when there is no label',\n       async () => {\n         // Setup.\n         // Test case.\n         const {instance} = await setupTest({required: true, label: undefined});\n         // Assertion.\n         expect(instance.labelText)\n             .withContext(\n                 'label text should be empty string if label is not provided, even when required')\n             .toBe('');\n       });\n  });\n});\n"]}