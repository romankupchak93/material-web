{"version":3,"file":"templates.js","sourceRoot":"","sources":["templates.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {TemplateResult} from 'lit';\nimport {DirectiveResult} from 'lit/directive.js';\nimport {ref} from 'lit/directives/ref.js';\nimport {literal, StaticValue} from 'lit/static-html.js';\n\nimport {Harness, HarnessElement, isElementWithHarness} from './harness.js';\nimport {TestTableTemplate} from './table/test-table.js';\n\n/**\n * Pre-defined test table template states commonly shared between components.\n */\nexport enum State {\n  DEFAULT = 'Default',\n  DISABLED = 'Disabled',\n  ERROR = 'Error',\n  FOCUS = 'Focus',\n  HOVER = 'Hover',\n  PRESSED = 'Pressed',\n}\n\n/**\n * A template builder class that can be used to easily build test table template\n * render functions for multiple variants.\n *\n * If a harness is used, invoke `.withHarness()` before `.withVariants()` for\n * accurate types.\n *\n * @example\n *   const templates = new TemplateBuilder()\n *      .withHarness(MyHarness)\n *      .withVariants({\n *        filled(directive, props) {\n *          return html`\n *            <my-filled-element .label=${props.label} ${directive}>\n *              ${props.content}\n *            </my-filled-element>\n *          `;\n *        },\n *        outlined(directive, props) {\n *          return html`\n *            <my-outlined-element .label=${props.label} ${directive}>\n *              ${props.content}\n *            </my-outlined-element>\n *          `;\n *        },\n *      });\n *\n *   // Create an array of templates for every variant and provided property\n *   // object. This example creates both variants with and without a label.\n *   const testTemplates = templates.all({label: 'Foo'}, {});\n *\n *   // Create specific variant templates. Useful for when the properties are\n *   // not the same for each rendered variant.\n *   const variantTemplates = [\n *     templates.variant('filled', {label: 'Filled'}),\n *     templates.variant('filled', {label: ''}),\n *     templates.variant('outlined', {label: 'outlined'}, {}),\n *     templates.variant('outlined', {label: ''}, {}),\n *   ];\n *\n * @template H Optional element harness type.\n * @template V Variant name types.\n */\nexport class TemplateBuilder<H extends Harness = never,\n                                       V extends string = never> {\n  /**\n   * A map of variant names and their template factories.\n   */\n  private readonly variants = new Map<V, TemplateVariant<H>>();\n  /**\n   * The current harness constructor to use when rendering.\n   */\n  private harnessCtor?: new(element: HarnessElement<H>) => H;\n  /**\n   * The current state callback to invoke after rendering.\n   */\n  private stateCallback?: TemplateStateCallback<H>;\n\n  /**\n   * Creates and return an array of test table templates that will render every\n   * variant once for each test case element properties object provided.\n   *\n   * @param testCaseProps Element properties to render for every variant.\n   * @return An array of test table templates for every variant and test case.\n   */\n  all(...testCaseProps: Array<TemplateProps<H>>): TestTableTemplate[] {\n    if (!testCaseProps.length) {\n      // Allow calling templates.all() and assume default props.\n      testCaseProps.push({});\n    }\n\n    return Array.from(this.variants.values()).flatMap(({display, factory}) => {\n      return testCaseProps.map(props => ({display, render: factory(props)}));\n    });\n  }\n\n  /**\n   * Creates and returns the test table template for a specific variant and\n   * test case.\n   *\n   * @param variant The variant to render.\n   * @param testCaseProps Element properties to render for this variant.\n   * @return A test table template for the given variant and test case.\n   */\n  variant(variant: V, testCaseProps?: TemplateProps<H>): TestTableTemplate {\n    const displayAndRender = this.variants.get(variant);\n    if (!displayAndRender) {\n      throw new Error(`Missing variant '${variant}' in TemplateBuilder.`);\n    }\n\n    const {display, factory} = displayAndRender;\n    const render = factory(testCaseProps);\n    return {display, render};\n  }\n\n  /**\n   * Sets the harness constructor to use for the template builder.\n   *\n   * @template NewHarness The new harness type.\n   * @param harnessCtor The constructor for the harness.\n   * @return The template builder, now using the provided harness type.\n   */\n  withHarness<NewHarness extends Harness>(\n      harnessCtor: new(element: HarnessElement<NewHarness>) => NewHarness) {\n    const typedThis = this as unknown as TemplateBuilder<NewHarness, V>;\n    typedThis.harnessCtor = harnessCtor;\n    return typedThis;\n  }\n\n  /**\n   * Sets the state callback to use for the template builder. It is invoked\n   * after the template's element has rendered and provides the current state\n   * and harness.\n   *\n   * This callback is typically used when additional behavior needs to be\n   * simulated with the harness according to the current state.\n   *\n   * @example\n   *   // Element-specific state that does not belong in the shared `State`\n   *   // enum.\n   *   enum MyState {\n   *     FOCUS_MOUSE = 'Focus (Mouse)', // A unique state\n   *   }\n   *\n   *   const templates = new TemplateBuilder()\n   *       .withHarness(MyHarness)\n   *       .withStateCallback(async (state, harness) => {\n   *         // Use the harness to perform additional behavior not handled\n   *         // by default.\n   *         if (state === MyState.FOCUS_MOUSE) {\n   *           await harness.focusWithMouse();\n   *         }\n   *       })\n   *       .withVariants({/* ... *\\/})\n   *\n   * @template NewHarness The new harness type.\n   * @param callback The callback to be called.\n   * @return The template builder, now using the provided harness type.\n   */\n  withStateCallback(callback: TemplateStateCallback<H>) {\n    this.stateCallback = callback;\n    return this;\n  }\n\n  /**\n   * Adds multiple variant render functions to the template builder.\n   *\n   * @param variants An object whose keys are variant names and values are\n   *     either variant render functions or an object of variant options. The\n   *     options specify a `display` name and the variant `render` function.\n   * @return The template builder, now using the provided variants.\n   */\n  withVariants(\n      variants: Record<string, TemplateRender<H>|TemplateVariantOptions<H>>) {\n    // TODO: clean this up by only allowing TemplateVariantOptions and force\n    // users to specify the display name.\n    for (const variant of Object.keys(variants)) {\n      this.withVariant(variant, variants[variant]);\n    }\n\n    return this as unknown as\n        TemplateBuilder<H, V|Extract<keyof typeof variants, string>>;\n  }\n\n  /**\n   * Adds a variant render function to the template builder.\n   *\n   * @param variant The new variant name to add.\n   * @param renderOrOptions The variant's render function, or an object with the\n   *     `render` function and a `display` name. The default display name is the\n   *     `variant` name when a render function is provided instead.\n   * @return The template builder, now using the provided variant.\n   */\n  withVariant<NewVariant extends string>(\n      variant: NewVariant,\n      renderOrOptions: TemplateRender<H>|TemplateVariantOptions<H>) {\n    // TODO: clean this up by only allowing TemplateVariantOptions and force\n    // users to specify the display name.\n    const typedThis = this as unknown as TemplateBuilder<H, V|NewVariant>;\n    const {display, render} = typeof renderOrOptions === 'function' ?\n        {display: variant, render: renderOrOptions} :\n        renderOrOptions;\n\n    typedThis.variants.set(variant, {\n      display: display ?? variant,\n      factory: props => {\n        return state => {\n          const directive = ref(async element => {\n            if (!element) {\n              return;\n            }\n\n            const harness = await this.createHarnessAndApplyState(\n                element as HarnessElement<H>, state);\n\n            // Allow the component to apply additional state or perform custom\n            // state logic.\n            this.stateCallback?.(state, harness);\n          });\n\n          return render(directive, props || {}, state);\n        };\n      }\n    });\n\n    return typedThis;\n  }\n\n  /**\n   * Creates a harness for the given element (if a harness constructor is\n   * being used). This function will also apply default shared state, including\n   * focusing, hovering, and pressing the element.\n   *\n   * @param element The element to create a harness for.\n   * @param state The current state of the element.\n   * @return The created harness, or undefined if a harness constructor is not\n   *     being used.\n   */\n  private async createHarnessAndApplyState(\n      element: HarnessElement<H>, state: string): Promise<H|never> {\n    if (!this.harnessCtor) {\n      return undefined as never;\n    }\n\n    const harness = isElementWithHarness(element) ?\n        element.harness as H :\n        new this.harnessCtor(element);\n    // Common shared component state harness actions\n    await harness.reset();\n    switch (state) {\n      case State.FOCUS:\n        await harness.focusWithKeyboard();\n        break;\n      case State.HOVER:\n        await harness.startHover();\n        break;\n      case State.PRESSED:\n        await harness.startClickWithMouse();\n        break;\n      default:\n        break;\n    }\n\n    return harness;\n  }\n}\n\n/**\n * A template variant, which includes the display name of the variant and a\n * factory to create `TestTableTemplate` objects.\n *\n * @template H The harness type.\n */\nexport interface TemplateVariant<H extends Harness> {\n  /** The variant's display name. */\n  display: string|StaticValue;\n  /**\n   * A factory function that takes an object of element properties and returns\n   * another a test table template that renders the variant's element for a\n   * given state.\n   *\n   * @template H The harness type.\n   * @param props Optional properties for the element.\n   * @return A function that renders the element for a given state.\n   */\n  factory: (props?: TemplateProps<H>) => TestTableTemplate['render'];\n}\n\n/** Options for rendering a template variant. */\nexport interface TemplateVariantOptions<H extends Harness> {\n  /** A function to render this variant. */\n  render: TemplateRender<H>;\n  /** Custom variant display name. Defaults to the name of the variant. */\n  display?: string|ReturnType<typeof literal>;\n}\n\n// TODO: clean this devx up a bit by swapping props/state args\n/**\n * A function that renders a variant to display. The function receives a test\n * directive that should be added to the element.\n *\n * If a harness for the element is used, optional properties for the harness's\n * element are provided to bind to the template.\n *\n * The render function may also use a third parameter, which is the current\n * state the element should be rendered in.\n *\n * @template H The harness type.\n * @param directive A test directive that should be placed on the element.\n * @param props Properties for the element.\n * @param state The current state to render the element in.\n * @return A `TemplateResult` rendering the element.\n */\nexport type TemplateRender<H extends Harness> =\n    (directive: DirectiveResult, props: TemplateProps<H>, state: string) =>\n        TemplateResult|null;\n\n/**\n * A callback that is invoked after the template's element has rendered. It\n * provides the current state and harness (if used).\n *\n * This callback is typically used when additional behavior needs to be\n * simulated with the harness according to the current state.\n *\n * @template H The harness type.\n * @param state The current test table state.\n * @param harness The rendered element's harness.\n */\nexport type TemplateStateCallback<H extends Harness> =\n    (state: string, harness: H) => void;\n\n/**\n * Element properties for a harness constructor. Returns a partial object with\n * shared template properties and optional properties that are unique to the\n * element itself (excludes `HTMLElement` properties).\n *\n * @template H The harness type.\n */\nexport type TemplateProps<H extends Harness> = Partial<Pick<\n    HarnessElement<H>, Exclude<keyof HarnessElement<H>, keyof HTMLElement>>>&\n    SharedTemplateProps;\n\n/**\n * Shared element properties for all harnesses.\n */\nexport interface SharedTemplateProps {\n  /**\n   * The light DOM content of the element.\n   */\n  content?: TemplateResult;\n}\n"]}